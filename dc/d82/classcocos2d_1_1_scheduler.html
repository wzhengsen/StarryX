<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>adxe: Scheduler Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">adxe
   &#160;<span id="projectnumber">v1</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('dc/d82/classcocos2d_1_1_scheduler.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="../../da/d35/classcocos2d_1_1_scheduler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Scheduler Class Reference<div class="ingroups"><a class="el" href="../../dd/df2/group__base.html">Base</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html" title="Scheduler is responsible for triggering the scheduled callbacks.">Scheduler</a> is responsible for triggering the scheduled callbacks.  
 <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#details">More...</a></p>

<p>Inherits <a class="el" href="../../df/d28/classcocos2d_1_1_ref.html">Ref</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aedc30c04ff101a4b565502a378aacb9e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#aedc30c04ff101a4b565502a378aacb9e">Scheduler</a> ()</td></tr>
<tr class="memdesc:aedc30c04ff101a4b565502a378aacb9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#aedc30c04ff101a4b565502a378aacb9e">More...</a><br /></td></tr>
<tr class="separator:aedc30c04ff101a4b565502a378aacb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1db0a39d3aecb4a0c8f0f73795233b8"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#ac1db0a39d3aecb4a0c8f0f73795233b8">~Scheduler</a> ()</td></tr>
<tr class="memdesc:ac1db0a39d3aecb4a0c8f0f73795233b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#ac1db0a39d3aecb4a0c8f0f73795233b8">More...</a><br /></td></tr>
<tr class="separator:ac1db0a39d3aecb4a0c8f0f73795233b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e97ae1981157ac7a50cbd93453e2401"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#a3e97ae1981157ac7a50cbd93453e2401">getTimeScale</a> ()</td></tr>
<tr class="memdesc:a3e97ae1981157ac7a50cbd93453e2401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the time scale of schedule callbacks.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#a3e97ae1981157ac7a50cbd93453e2401">More...</a><br /></td></tr>
<tr class="separator:a3e97ae1981157ac7a50cbd93453e2401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e13f19952bb9053fe510c70d8efed47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#a1e13f19952bb9053fe510c70d8efed47">setTimeScale</a> (float timeScale)</td></tr>
<tr class="memdesc:a1e13f19952bb9053fe510c70d8efed47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies the time of all scheduled callbacks.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#a1e13f19952bb9053fe510c70d8efed47">More...</a><br /></td></tr>
<tr class="separator:a1e13f19952bb9053fe510c70d8efed47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d15c24b9636f137cfe15a0db9a47c0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#a2d15c24b9636f137cfe15a0db9a47c0f">update</a> (float dt)</td></tr>
<tr class="memdesc:a2d15c24b9636f137cfe15a0db9a47c0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">'update' the scheduler.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#a2d15c24b9636f137cfe15a0db9a47c0f">More...</a><br /></td></tr>
<tr class="separator:a2d15c24b9636f137cfe15a0db9a47c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4345187fe4dab5c0aed3aa40ae784d7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#a4345187fe4dab5c0aed3aa40ae784d7a">schedule</a> (const ccSchedulerFunc &amp;callback, void *target, float interval, unsigned int repeat, float delay, bool paused, const std::string &amp;key)</td></tr>
<tr class="memdesc:a4345187fe4dab5c0aed3aa40ae784d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scheduled method will be called every 'interval' seconds.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#a4345187fe4dab5c0aed3aa40ae784d7a">More...</a><br /></td></tr>
<tr class="separator:a4345187fe4dab5c0aed3aa40ae784d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8cdca5f871a0e95ac3047c71d4452e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#adf8cdca5f871a0e95ac3047c71d4452e">schedule</a> (const ccSchedulerFunc &amp;callback, void *target, float interval, bool paused, const std::string &amp;key)</td></tr>
<tr class="memdesc:adf8cdca5f871a0e95ac3047c71d4452e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scheduled method will be called every 'interval' seconds for ever.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#adf8cdca5f871a0e95ac3047c71d4452e">More...</a><br /></td></tr>
<tr class="separator:adf8cdca5f871a0e95ac3047c71d4452e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0f54932e6dd2d0a6d9ac1ae41ff95f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#a4b0f54932e6dd2d0a6d9ac1ae41ff95f">schedule</a> (SEL_SCHEDULE selector, <a class="el" href="../../df/d28/classcocos2d_1_1_ref.html">Ref</a> *target, float interval, unsigned int repeat, float delay, bool paused)</td></tr>
<tr class="memdesc:a4b0f54932e6dd2d0a6d9ac1ae41ff95f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scheduled method will be called every <code>interval</code> seconds.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#a4b0f54932e6dd2d0a6d9ac1ae41ff95f">More...</a><br /></td></tr>
<tr class="separator:a4b0f54932e6dd2d0a6d9ac1ae41ff95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a014c44c169275a007450b97215ab2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#a4a014c44c169275a007450b97215ab2f">schedule</a> (SEL_SCHEDULE selector, <a class="el" href="../../df/d28/classcocos2d_1_1_ref.html">Ref</a> *target, float interval, bool paused)</td></tr>
<tr class="memdesc:a4a014c44c169275a007450b97215ab2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The scheduled method will be called every <code>interval</code> seconds for ever.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#a4a014c44c169275a007450b97215ab2f">More...</a><br /></td></tr>
<tr class="separator:a4a014c44c169275a007450b97215ab2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86f74fb8869d343245fabbd206ddbf8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad86f74fb8869d343245fabbd206ddbf8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#ad86f74fb8869d343245fabbd206ddbf8">scheduleUpdate</a> (T *target, int priority, bool paused)</td></tr>
<tr class="memdesc:ad86f74fb8869d343245fabbd206ddbf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules the 'update' selector for a given target with a given priority.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#ad86f74fb8869d343245fabbd206ddbf8">More...</a><br /></td></tr>
<tr class="separator:ad86f74fb8869d343245fabbd206ddbf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add571737305b5041c722e307f6ec251c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#add571737305b5041c722e307f6ec251c">unschedule</a> (const std::string &amp;key, void *target)</td></tr>
<tr class="memdesc:add571737305b5041c722e307f6ec251c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unschedules a callback for a key and a given target.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#add571737305b5041c722e307f6ec251c">More...</a><br /></td></tr>
<tr class="separator:add571737305b5041c722e307f6ec251c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7925726a63ba10a39fb1dbc11c367d76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#a7925726a63ba10a39fb1dbc11c367d76">unschedule</a> (SEL_SCHEDULE selector, <a class="el" href="../../df/d28/classcocos2d_1_1_ref.html">Ref</a> *target)</td></tr>
<tr class="memdesc:a7925726a63ba10a39fb1dbc11c367d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unschedules a selector for a given target.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#a7925726a63ba10a39fb1dbc11c367d76">More...</a><br /></td></tr>
<tr class="separator:a7925726a63ba10a39fb1dbc11c367d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999c840789479c6172111e68d9465de5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#a999c840789479c6172111e68d9465de5">unscheduleUpdate</a> (void *target)</td></tr>
<tr class="memdesc:a999c840789479c6172111e68d9465de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unschedules the update selector for a given target.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#a999c840789479c6172111e68d9465de5">More...</a><br /></td></tr>
<tr class="separator:a999c840789479c6172111e68d9465de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ab2fef7f073dcdd49cb77869d0e7a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#af2ab2fef7f073dcdd49cb77869d0e7a1">unscheduleAllForTarget</a> (void *target)</td></tr>
<tr class="memdesc:af2ab2fef7f073dcdd49cb77869d0e7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unschedules all selectors for a given target.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#af2ab2fef7f073dcdd49cb77869d0e7a1">More...</a><br /></td></tr>
<tr class="separator:af2ab2fef7f073dcdd49cb77869d0e7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74298fbc8ebf4de5acad87630be2422"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#ad74298fbc8ebf4de5acad87630be2422">unscheduleAll</a> ()</td></tr>
<tr class="memdesc:ad74298fbc8ebf4de5acad87630be2422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unschedules all selectors from all targets.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#ad74298fbc8ebf4de5acad87630be2422">More...</a><br /></td></tr>
<tr class="separator:ad74298fbc8ebf4de5acad87630be2422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00406e46947de31114e5b6e8d0b9efdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#a00406e46947de31114e5b6e8d0b9efdf">unscheduleAllWithMinPriority</a> (int minPriority)</td></tr>
<tr class="memdesc:a00406e46947de31114e5b6e8d0b9efdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unschedules all selectors from all targets with a minimum priority.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#a00406e46947de31114e5b6e8d0b9efdf">More...</a><br /></td></tr>
<tr class="separator:a00406e46947de31114e5b6e8d0b9efdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058a67e0f5f09a36558aa923affe4110"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#a058a67e0f5f09a36558aa923affe4110">isScheduled</a> (const std::string &amp;key, const void *target) const</td></tr>
<tr class="memdesc:a058a67e0f5f09a36558aa923affe4110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a callback associated with 'key' and 'target' is scheduled.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#a058a67e0f5f09a36558aa923affe4110">More...</a><br /></td></tr>
<tr class="separator:a058a67e0f5f09a36558aa923affe4110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab514af7a141bb1d462f9111c0f6cc96e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#ab514af7a141bb1d462f9111c0f6cc96e">isScheduled</a> (SEL_SCHEDULE selector, const <a class="el" href="../../df/d28/classcocos2d_1_1_ref.html">Ref</a> *target) const</td></tr>
<tr class="memdesc:ab514af7a141bb1d462f9111c0f6cc96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a selector for a given target is scheduled.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#ab514af7a141bb1d462f9111c0f6cc96e">More...</a><br /></td></tr>
<tr class="separator:ab514af7a141bb1d462f9111c0f6cc96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adacdc8ef24172343ddff7d82a4bfc665"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#adacdc8ef24172343ddff7d82a4bfc665">pauseTarget</a> (void *target)</td></tr>
<tr class="memdesc:adacdc8ef24172343ddff7d82a4bfc665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pauses the target.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#adacdc8ef24172343ddff7d82a4bfc665">More...</a><br /></td></tr>
<tr class="separator:adacdc8ef24172343ddff7d82a4bfc665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1ffc9acb54481d9b30d5e11b158257"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#a1f1ffc9acb54481d9b30d5e11b158257">resumeTarget</a> (void *target)</td></tr>
<tr class="memdesc:a1f1ffc9acb54481d9b30d5e11b158257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resumes the target.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#a1f1ffc9acb54481d9b30d5e11b158257">More...</a><br /></td></tr>
<tr class="separator:a1f1ffc9acb54481d9b30d5e11b158257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9a6f61ad489d382fc53b748c686567"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#a0d9a6f61ad489d382fc53b748c686567">isTargetPaused</a> (void *target)</td></tr>
<tr class="memdesc:a0d9a6f61ad489d382fc53b748c686567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the target is paused.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#a0d9a6f61ad489d382fc53b748c686567">More...</a><br /></td></tr>
<tr class="separator:a0d9a6f61ad489d382fc53b748c686567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dd3210e67e880e75f4f839c306a8b0"><td class="memItemLeft" align="right" valign="top">std::set&lt; void * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#a68dd3210e67e880e75f4f839c306a8b0">pauseAllTargets</a> ()</td></tr>
<tr class="memdesc:a68dd3210e67e880e75f4f839c306a8b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause all selectors from all targets.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#a68dd3210e67e880e75f4f839c306a8b0">More...</a><br /></td></tr>
<tr class="separator:a68dd3210e67e880e75f4f839c306a8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618ea3a9a549554bd86269357eda95a8"><td class="memItemLeft" align="right" valign="top">std::set&lt; void * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#a618ea3a9a549554bd86269357eda95a8">pauseAllTargetsWithMinPriority</a> (int minPriority)</td></tr>
<tr class="memdesc:a618ea3a9a549554bd86269357eda95a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pause all selectors from all targets with a minimum priority.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#a618ea3a9a549554bd86269357eda95a8">More...</a><br /></td></tr>
<tr class="separator:a618ea3a9a549554bd86269357eda95a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5bc911247670423dd0b48948b7b7e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#a3c5bc911247670423dd0b48948b7b7e8">resumeTargets</a> (const std::set&lt; void * &gt; &amp;targetsToResume)</td></tr>
<tr class="memdesc:a3c5bc911247670423dd0b48948b7b7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resume selectors on a set of targets.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#a3c5bc911247670423dd0b48948b7b7e8">More...</a><br /></td></tr>
<tr class="separator:a3c5bc911247670423dd0b48948b7b7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4151e75ec796f5f124882da6a0ba02c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#a4151e75ec796f5f124882da6a0ba02c2">performFunctionInCocosThread</a> (std::function&lt; void()&gt; function)</td></tr>
<tr class="memdesc:a4151e75ec796f5f124882da6a0ba02c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls a function on the <a class="el" href="../../d2/dc0/namespacecocos2d.html" title="Copyright 2013 BlackBerry Inc.">cocos2d</a> thread.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#a4151e75ec796f5f124882da6a0ba02c2">More...</a><br /></td></tr>
<tr class="separator:a4151e75ec796f5f124882da6a0ba02c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac576d2ea3ad5edb8c3f9c3914ea6b421"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#ac576d2ea3ad5edb8c3f9c3914ea6b421">removeAllFunctionsToBePerformedInCocosThread</a> ()</td></tr>
<tr class="memdesc:ac576d2ea3ad5edb8c3f9c3914ea6b421"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all pending functions queued to be performed with <a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#a4151e75ec796f5f124882da6a0ba02c2" title="Calls a function on the cocos2d thread.">Scheduler::performFunctionInCocosThread</a> Functions unscheduled in this manner will not be executed This function is thread safe.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#ac576d2ea3ad5edb8c3f9c3914ea6b421">More...</a><br /></td></tr>
<tr class="separator:ac576d2ea3ad5edb8c3f9c3914ea6b421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcocos2d_1_1_ref"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcocos2d_1_1_ref')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../df/d28/classcocos2d_1_1_ref.html">Ref</a></td></tr>
<tr class="memitem:a24888ae1fe9df2d329c9b485807cb62b inherit pub_methods_classcocos2d_1_1_ref"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d28/classcocos2d_1_1_ref.html#a24888ae1fe9df2d329c9b485807cb62b">retain</a> ()</td></tr>
<tr class="memdesc:a24888ae1fe9df2d329c9b485807cb62b inherit pub_methods_classcocos2d_1_1_ref"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retains the ownership.  <a href="../../df/d28/classcocos2d_1_1_ref.html#a24888ae1fe9df2d329c9b485807cb62b">More...</a><br /></td></tr>
<tr class="separator:a24888ae1fe9df2d329c9b485807cb62b inherit pub_methods_classcocos2d_1_1_ref"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b477d0e2d399f75d585d154c346591 inherit pub_methods_classcocos2d_1_1_ref"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d28/classcocos2d_1_1_ref.html#a23b477d0e2d399f75d585d154c346591">release</a> ()</td></tr>
<tr class="memdesc:a23b477d0e2d399f75d585d154c346591 inherit pub_methods_classcocos2d_1_1_ref"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the ownership immediately.  <a href="../../df/d28/classcocos2d_1_1_ref.html#a23b477d0e2d399f75d585d154c346591">More...</a><br /></td></tr>
<tr class="separator:a23b477d0e2d399f75d585d154c346591 inherit pub_methods_classcocos2d_1_1_ref"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2345cdb9d96629de5dbaf88e36d505 inherit pub_methods_classcocos2d_1_1_ref"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/d28/classcocos2d_1_1_ref.html">Ref</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d28/classcocos2d_1_1_ref.html#a8a2345cdb9d96629de5dbaf88e36d505">autorelease</a> ()</td></tr>
<tr class="memdesc:a8a2345cdb9d96629de5dbaf88e36d505 inherit pub_methods_classcocos2d_1_1_ref"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the ownership sometime soon automatically.  <a href="../../df/d28/classcocos2d_1_1_ref.html#a8a2345cdb9d96629de5dbaf88e36d505">More...</a><br /></td></tr>
<tr class="separator:a8a2345cdb9d96629de5dbaf88e36d505 inherit pub_methods_classcocos2d_1_1_ref"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f5c543c1504195eb40b1dcc4d1e794 inherit pub_methods_classcocos2d_1_1_ref"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d28/classcocos2d_1_1_ref.html#a00f5c543c1504195eb40b1dcc4d1e794">getReferenceCount</a> () const</td></tr>
<tr class="memdesc:a00f5c543c1504195eb40b1dcc4d1e794 inherit pub_methods_classcocos2d_1_1_ref"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="../../df/d28/classcocos2d_1_1_ref.html" title="Ref is used for reference count management.">Ref</a>'s current reference count.  <a href="../../df/d28/classcocos2d_1_1_ref.html#a00f5c543c1504195eb40b1dcc4d1e794">More...</a><br /></td></tr>
<tr class="separator:a00f5c543c1504195eb40b1dcc4d1e794 inherit pub_methods_classcocos2d_1_1_ref"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fca001f1d40ace24096674c50e783d5 inherit pub_methods_classcocos2d_1_1_ref"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d28/classcocos2d_1_1_ref.html#a2fca001f1d40ace24096674c50e783d5">~Ref</a> ()</td></tr>
<tr class="memdesc:a2fca001f1d40ace24096674c50e783d5 inherit pub_methods_classcocos2d_1_1_ref"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="../../df/d28/classcocos2d_1_1_ref.html#a2fca001f1d40ace24096674c50e783d5">More...</a><br /></td></tr>
<tr class="separator:a2fca001f1d40ace24096674c50e783d5 inherit pub_methods_classcocos2d_1_1_ref"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ad8905692db88d99f3e8a7deea771ee85"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#ad8905692db88d99f3e8a7deea771ee85">PRIORITY_SYSTEM</a></td></tr>
<tr class="memdesc:ad8905692db88d99f3e8a7deea771ee85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Priority level reserved for system services.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#ad8905692db88d99f3e8a7deea771ee85">More...</a><br /></td></tr>
<tr class="separator:ad8905692db88d99f3e8a7deea771ee85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d16bd88446a11ec0acf21e85384102"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#a75d16bd88446a11ec0acf21e85384102">PRIORITY_NON_SYSTEM_MIN</a></td></tr>
<tr class="memdesc:a75d16bd88446a11ec0acf21e85384102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum priority level for user scheduling.  <a href="../../dc/d82/classcocos2d_1_1_scheduler.html#a75d16bd88446a11ec0acf21e85384102">More...</a><br /></td></tr>
<tr class="separator:a75d16bd88446a11ec0acf21e85384102"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html" title="Scheduler is responsible for triggering the scheduled callbacks.">Scheduler</a> is responsible for triggering the scheduled callbacks. </p>
<p>You should not use system timer for your game logic. Instead, use this class.</p>
<p>There are 2 different types of callbacks (selectors):</p>
<ul>
<li>update selector: the 'update' selector will be called every frame. You can customize the priority.</li>
<li>custom selector: A custom selector will be called every frame, or with a custom interval of time</li>
</ul>
<p>The 'custom selectors' should be avoided when possible. It is faster, and consumes less memory to use the 'update selector'. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aedc30c04ff101a4b565502a378aacb9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc30c04ff101a4b565502a378aacb9e">&#9670;&nbsp;</a></span>Scheduler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html">Scheduler</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>@js ctor </p>

</div>
</div>
<a id="ac1db0a39d3aecb4a0c8f0f73795233b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1db0a39d3aecb4a0c8f0f73795233b8">&#9670;&nbsp;</a></span>~Scheduler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ~<a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html">Scheduler</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>@js NA @lua NA </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3e97ae1981157ac7a50cbd93453e2401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e97ae1981157ac7a50cbd93453e2401">&#9670;&nbsp;</a></span>getTimeScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float getTimeScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the time scale of schedule callbacks. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#a1e13f19952bb9053fe510c70d8efed47" title="Modifies the time of all scheduled callbacks.">Scheduler::setTimeScale()</a> </dd></dl>

</div>
</div>
<a id="a1e13f19952bb9053fe510c70d8efed47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e13f19952bb9053fe510c70d8efed47">&#9670;&nbsp;</a></span>setTimeScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setTimeScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>timeScale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modifies the time of all scheduled callbacks. </p>
<p>You can use this property to create a 'slow motion' or 'fast forward' effect. Default is 1.0. To create a 'slow motion' effect, use values below 1.0. To create a 'fast forward' effect, use values higher than 1.0. </p><dl class="section since"><dt>Since</dt><dd>v0.8 </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>It will affect EVERY scheduled selector / action. </dd></dl>

</div>
</div>
<a id="a2d15c24b9636f137cfe15a0db9a47c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d15c24b9636f137cfe15a0db9a47c0f">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void update </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>'update' the scheduler. </p>
<p>You should NEVER call this method, unless you know what you are doing. @lua NA </p>

</div>
</div>
<a id="a4345187fe4dab5c0aed3aa40ae784d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4345187fe4dab5c0aed3aa40ae784d7a">&#9670;&nbsp;</a></span>schedule() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void schedule </td>
          <td>(</td>
          <td class="paramtype">const ccSchedulerFunc &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>repeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paused</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The scheduled method will be called every 'interval' seconds. </p>
<p>If paused is true, then it won't be called until it is resumed. If 'interval' is 0, it will be called every frame, but if so, it's recommended to use 'scheduleUpdate' instead. If the 'callback' is already scheduled, then only the interval parameter will be updated without re-scheduling it again. repeat let the action be repeated repeat + 1 times, use CC_REPEAT_FOREVER to let the action run continuously delay is the amount of time the action will wait before it'll start. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback function. </td></tr>
    <tr><td class="paramname">target</td><td>The target of the callback function. </td></tr>
    <tr><td class="paramname">interval</td><td>The interval to schedule the callback. If the value is 0, then the callback will be scheduled every frame. </td></tr>
    <tr><td class="paramname">repeat</td><td>repeat+1 times to schedule the callback. </td></tr>
    <tr><td class="paramname">delay</td><td>Schedule call back after <code>delay</code> seconds. If the value is not 0, the first schedule will happen after <code>delay</code> seconds. But it will only affect first schedule. After first schedule, the delay time is determined by <code>interval</code>. </td></tr>
    <tr><td class="paramname">paused</td><td>Whether or not to pause the schedule. </td></tr>
    <tr><td class="paramname">key</td><td>The key to identify the callback function, because there is not way to identify a std::function&lt;&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.0 </dd></dl>

</div>
</div>
<a id="adf8cdca5f871a0e95ac3047c71d4452e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf8cdca5f871a0e95ac3047c71d4452e">&#9670;&nbsp;</a></span>schedule() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void schedule </td>
          <td>(</td>
          <td class="paramtype">const ccSchedulerFunc &amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paused</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The scheduled method will be called every 'interval' seconds for ever. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback function. </td></tr>
    <tr><td class="paramname">target</td><td>The target of the callback function. </td></tr>
    <tr><td class="paramname">interval</td><td>The interval to schedule the callback. If the value is 0, then the callback will be scheduled every frame. </td></tr>
    <tr><td class="paramname">paused</td><td>Whether or not to pause the schedule. </td></tr>
    <tr><td class="paramname">key</td><td>The key to identify the callback function, because there is not way to identify a std::function&lt;&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.0 </dd></dl>

</div>
</div>
<a id="a4b0f54932e6dd2d0a6d9ac1ae41ff95f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0f54932e6dd2d0a6d9ac1ae41ff95f">&#9670;&nbsp;</a></span>schedule() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void schedule </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/d28/classcocos2d_1_1_ref.html">Ref</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>repeat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>delay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The scheduled method will be called every <code>interval</code> seconds. </p>
<p>If paused is true, then it won't be called until it is resumed. If 'interval' is 0, it will be called every frame, but if so, it's recommended to use 'scheduleUpdate' instead. If the selector is already scheduled, then only the interval parameter will be updated without re-scheduling it again. repeat let the action be repeated repeat + 1 times, use CC_REPEAT_FOREVER to let the action run continuously delay is the amount of time the action will wait before it'll start</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>The callback function. </td></tr>
    <tr><td class="paramname">target</td><td>The target of the callback function. </td></tr>
    <tr><td class="paramname">interval</td><td>The interval to schedule the callback. If the value is 0, then the callback will be scheduled every frame. </td></tr>
    <tr><td class="paramname">repeat</td><td>repeat+1 times to schedule the callback. </td></tr>
    <tr><td class="paramname">delay</td><td>Schedule call back after <code>delay</code> seconds. If the value is not 0, the first schedule will happen after <code>delay</code> seconds. But it will only affect first schedule. After first schedule, the delay time is determined by <code>interval</code>. </td></tr>
    <tr><td class="paramname">paused</td><td>Whether or not to pause the schedule. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.0 </dd></dl>

</div>
</div>
<a id="a4a014c44c169275a007450b97215ab2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a014c44c169275a007450b97215ab2f">&#9670;&nbsp;</a></span>schedule() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void schedule </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/d28/classcocos2d_1_1_ref.html">Ref</a> *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The scheduled method will be called every <code>interval</code> seconds for ever. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>The callback function. </td></tr>
    <tr><td class="paramname">target</td><td>The target of the callback function. </td></tr>
    <tr><td class="paramname">interval</td><td>The interval to schedule the callback. If the value is 0, then the callback will be scheduled every frame. </td></tr>
    <tr><td class="paramname">paused</td><td>Whether or not to pause the schedule. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad86f74fb8869d343245fabbd206ddbf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad86f74fb8869d343245fabbd206ddbf8">&#9670;&nbsp;</a></span>scheduleUpdate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void scheduleUpdate </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Schedules the 'update' selector for a given target with a given priority. </p>
<p>The 'update' selector will be called every frame. The lower the priority, the earlier it is called. </p><dl class="section since"><dt>Since</dt><dd>v3.0 @lua NA </dd></dl>

</div>
</div>
<a id="add571737305b5041c722e307f6ec251c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add571737305b5041c722e307f6ec251c">&#9670;&nbsp;</a></span>unschedule() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unschedule </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unschedules a callback for a key and a given target. </p>
<p>If you want to unschedule the 'callbackPerFrame', use unscheduleUpdate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the callback function, because there is not way to identify a std::function&lt;&gt;. </td></tr>
    <tr><td class="paramname">target</td><td>The target to be unscheduled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.0 </dd></dl>

</div>
</div>
<a id="a7925726a63ba10a39fb1dbc11c367d76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7925726a63ba10a39fb1dbc11c367d76">&#9670;&nbsp;</a></span>unschedule() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unschedule </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/d28/classcocos2d_1_1_ref.html">Ref</a> *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unschedules a selector for a given target. </p>
<p>If you want to unschedule the "update", use <code><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#a999c840789479c6172111e68d9465de5" title="Unschedules the update selector for a given target.">unscheduleUpdate()</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>The selector that is unscheduled. </td></tr>
    <tr><td class="paramname">target</td><td>The target of the unscheduled selector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.0 </dd></dl>

</div>
</div>
<a id="a999c840789479c6172111e68d9465de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a999c840789479c6172111e68d9465de5">&#9670;&nbsp;</a></span>unscheduleUpdate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unscheduleUpdate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unschedules the update selector for a given target. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target to be unscheduled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.3 </dd></dl>

</div>
</div>
<a id="af2ab2fef7f073dcdd49cb77869d0e7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ab2fef7f073dcdd49cb77869d0e7a1">&#9670;&nbsp;</a></span>unscheduleAllForTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unscheduleAllForTarget </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unschedules all selectors for a given target. </p>
<p>This also includes the "update" selector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target to be unscheduled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.3 @lua NA </dd></dl>

</div>
</div>
<a id="ad74298fbc8ebf4de5acad87630be2422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74298fbc8ebf4de5acad87630be2422">&#9670;&nbsp;</a></span>unscheduleAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unscheduleAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unschedules all selectors from all targets. </p>
<p>You should NEVER call this method, unless you know what you are doing. </p><dl class="section since"><dt>Since</dt><dd>v0.99.3 </dd></dl>

</div>
</div>
<a id="a00406e46947de31114e5b6e8d0b9efdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00406e46947de31114e5b6e8d0b9efdf">&#9670;&nbsp;</a></span>unscheduleAllWithMinPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void unscheduleAllWithMinPriority </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minPriority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unschedules all selectors from all targets with a minimum priority. </p>
<p>You should only call this with <code>PRIORITY_NON_SYSTEM_MIN</code> or higher. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minPriority</td><td>The minimum priority of selector to be unscheduled. Which means, all selectors which priority is higher than minPriority will be unscheduled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v2.0.0 </dd></dl>

</div>
</div>
<a id="a058a67e0f5f09a36558aa923affe4110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058a67e0f5f09a36558aa923affe4110">&#9670;&nbsp;</a></span>isScheduled() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isScheduled </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a callback associated with 'key' and 'target' is scheduled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the callback function, because there is not way to identify a std::function&lt;&gt;. </td></tr>
    <tr><td class="paramname">target</td><td>The target of the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified callback is invoked, false if not. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v3.0.0 </dd></dl>

</div>
</div>
<a id="ab514af7a141bb1d462f9111c0f6cc96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab514af7a141bb1d462f9111c0f6cc96e">&#9670;&nbsp;</a></span>isScheduled() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isScheduled </td>
          <td>(</td>
          <td class="paramtype">SEL_SCHEDULE&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d28/classcocos2d_1_1_ref.html">Ref</a> *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether a selector for a given target is scheduled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>The selector to be checked. </td></tr>
    <tr><td class="paramname">target</td><td>The target of the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified selector is invoked, false if not. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v3.0 </dd></dl>

</div>
</div>
<a id="adacdc8ef24172343ddff7d82a4bfc665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adacdc8ef24172343ddff7d82a4bfc665">&#9670;&nbsp;</a></span>pauseTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pauseTarget </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pauses the target. </p>
<p>All scheduled selectors/update for a given target won't be 'ticked' until the target is resumed. If the target is not present, nothing happens. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target to be paused. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.3 </dd></dl>

</div>
</div>
<a id="a1f1ffc9acb54481d9b30d5e11b158257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1ffc9acb54481d9b30d5e11b158257">&#9670;&nbsp;</a></span>resumeTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void resumeTarget </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resumes the target. </p>
<p>The 'target' will be unpaused, so all schedule selectors/update will be 'ticked' again. If the target is not present, nothing happens. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target to be resumed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v0.99.3 </dd></dl>

</div>
</div>
<a id="a0d9a6f61ad489d382fc53b748c686567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9a6f61ad489d382fc53b748c686567">&#9670;&nbsp;</a></span>isTargetPaused()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isTargetPaused </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether or not the target is paused. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The target to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the target is paused, false if not. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>v1.0.0 @lua NA </dd></dl>

</div>
</div>
<a id="a68dd3210e67e880e75f4f839c306a8b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68dd3210e67e880e75f4f839c306a8b0">&#9670;&nbsp;</a></span>pauseAllTargets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;void*&gt; pauseAllTargets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause all selectors from all targets. </p>
<p>You should NEVER call this method, unless you know what you are doing. </p><dl class="section since"><dt>Since</dt><dd>v2.0.0 </dd></dl>

</div>
</div>
<a id="a618ea3a9a549554bd86269357eda95a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618ea3a9a549554bd86269357eda95a8">&#9670;&nbsp;</a></span>pauseAllTargetsWithMinPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;void*&gt; pauseAllTargetsWithMinPriority </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minPriority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pause all selectors from all targets with a minimum priority. </p>
<p>You should only call this with PRIORITY_NON_SYSTEM_MIN or higher. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minPriority</td><td>The minimum priority of selector to be paused. Which means, all selectors which priority is higher than minPriority will be paused. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v2.0.0 </dd></dl>

</div>
</div>
<a id="a3c5bc911247670423dd0b48948b7b7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5bc911247670423dd0b48948b7b7e8">&#9670;&nbsp;</a></span>resumeTargets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void resumeTargets </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; void * &gt; &amp;&#160;</td>
          <td class="paramname"><em>targetsToResume</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resume selectors on a set of targets. </p>
<p>This can be useful for undoing a call to pauseAllSelectors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetsToResume</td><td>The set of targets to be resumed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v2.0.0 </dd></dl>

</div>
</div>
<a id="a4151e75ec796f5f124882da6a0ba02c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4151e75ec796f5f124882da6a0ba02c2">&#9670;&nbsp;</a></span>performFunctionInCocosThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void performFunctionInCocosThread </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls a function on the <a class="el" href="../../d2/dc0/namespacecocos2d.html" title="Copyright 2013 BlackBerry Inc.">cocos2d</a> thread. </p>
<p>Useful when you need to call a <a class="el" href="../../d2/dc0/namespacecocos2d.html" title="Copyright 2013 BlackBerry Inc.">cocos2d</a> function from another thread. This function is thread safe. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>The function to be run in <a class="el" href="../../d2/dc0/namespacecocos2d.html" title="Copyright 2013 BlackBerry Inc.">cocos2d</a> thread. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>v3.0 @js NA </dd></dl>

</div>
</div>
<a id="ac576d2ea3ad5edb8c3f9c3914ea6b421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac576d2ea3ad5edb8c3f9c3914ea6b421">&#9670;&nbsp;</a></span>removeAllFunctionsToBePerformedInCocosThread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void removeAllFunctionsToBePerformedInCocosThread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all pending functions queued to be performed with <a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html#a4151e75ec796f5f124882da6a0ba02c2" title="Calls a function on the cocos2d thread.">Scheduler::performFunctionInCocosThread</a> Functions unscheduled in this manner will not be executed This function is thread safe. </p>
<dl class="section since"><dt>Since</dt><dd>v3.14 @js NA </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad8905692db88d99f3e8a7deea771ee85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8905692db88d99f3e8a7deea771ee85">&#9670;&nbsp;</a></span>PRIORITY_SYSTEM</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int PRIORITY_SYSTEM</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Priority level reserved for system services. </p>
<p>@lua NA @js NA </p>

</div>
</div>
<a id="a75d16bd88446a11ec0acf21e85384102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d16bd88446a11ec0acf21e85384102">&#9670;&nbsp;</a></span>PRIORITY_NON_SYSTEM_MIN</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int PRIORITY_NON_SYSTEM_MIN</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Minimum priority level for user scheduling. </p>
<p>Priority level of user scheduling should bigger then this value.</p>
<p>@lua NA @js NA </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>CCScheduler.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d2/dc0/namespacecocos2d.html">cocos2d</a></li><li class="navelem"><a class="el" href="../../dc/d82/classcocos2d_1_1_scheduler.html">Scheduler</a></li>
    <li class="footer">Generated on Wed Jul 7 2021 04:22:47 for adxe by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
